<?php

/**
 * @file
 * Search integration for the API module.
 */

/**
 * Implements hook_help().
 */
function api_search_help($path, $arg) {
  switch ($path) {
    case 'admin/help#api_search':
      return t('The API Search Integration module provides search integration (Drupal Core search and Solr search with project https://drupal.org/project/apachesolr) for the API module.');
  }
}

/**
 * Implements hook_node_view().
 *
 * Sets up API documentation "nodes" so that they can be viewed with
 * node_view(), which hopefully only would be invoked during search indexing
 * and search results.
 */
function api_search_node_view($node, $view_mode, $langcode) {
  if ($node->type != 'api') {
    return;
  }

  // Load by documentation (node) ID. Try to load as a function if possible.
  $did = (int) $node->nid;
  if ($did <= 0) {
    return;
  }
  $doc = api_object_load($did, NULL, 'function');
  if (!$doc || !$doc->branch_id) {
    return;
  }

  $title = api_search_make_node_title($doc);
  if (!$title) {
    return;
  }

  $node->title = $title;

  // Add extra fields of information.
  $fields = array('namespaced_name', 'modifiers', 'object_type', 'summary', 'documentation', 'var', 'parameters', 'return_value', 'throws');

  foreach ($fields as $field) {
    if (isset($doc->$field) && trim($doc->$field)) {
      $node->content['api_' . $field] = array(
        '#markup' => '<div>' . $doc->$field . '</div>',
      );
    }
  }
}

/**
 * Implements hook_api_updated().
 *
 * Notifies the Solr module when a documentation "node" has been updated and
 * needs to be reparsed. Same for Core search/node module searching.
 */
function api_search_api_updated($dids) {
  $dosolr = module_exists('apachesolr');
  $docore = module_exists('search');
  foreach ($dids as $did) {
    if ($dosolr) {
      apachesolr_mark_entity('node', $did);
    }
    if ($docore) {
      search_touch_node($did);
    }
  }
}

/**
 * Implements hook_url_outbound_alter().
 *
 * Alters node/* URLs pointing to fake API docs nodes so that they instead
 * go to the API module's URL for the documentation item.
 */
function api_search_url_outbound_alter(&$path, &$options, $original_path) {
  $matches = array();
  if (preg_match('|^node/(\d+)$|', $path, $matches)) {
    $nid = (int) $matches[1];
    if ($nid > 0) {
      $doc = api_object_load($nid);
      if ($doc) {
        $path = api_url($doc);
      }
    }
  }
}

/**
 * Implements hook_api_ignore_node_access().
 */
function api_search_api_ignore_node_access($query) {
  // Skip processing if this is a search query from the Core Search module or
  // Apache Solr search module. But only if the current user has
  // "access api reference" permissions.
  if (!user_access('access API reference')) {
    return FALSE;
  }

  // There isn't a great way to test for it being a core Search query,
  // unfortunately. There's supposed to be a tag but it's added too late due
  // to a core bug. So, see if the first table is {search_index}.
  $tables = $query->getTables();
  $first = reset($tables);
  if (is_array($first) && isset($first['table']) && $first['table'] == 'search_index') {
    return TRUE;
  }

  // For Apache Solr, the query should be a subclass of
  // DrupalSolrQueryInterface.
  if ($query instanceof DrupalSolrQueryInterface) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter() for apachesolr_index_config_form().
 *
 * Makes the API fake node type appear as an indexable bundle in the checkbox
 * list.
 */
function api_search_form_apachesolr_index_config_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['config']['entities']['node'])) {
    $options = $form['config']['entities']['node']['#options'];
    $options['api'] = t('API reference entries');
    asort($options);
    $form['config']['entities']['node']['#options'] = $options;
  }
}

/**
 * Implements hook_apachesolr_index_document_build_ENTITY_TYPE() (node).
 *
 * Node title is set in the Solr indexing document earlier than the call to
 * node_view(), so we have to fix it after the fact. Also, we add custom
 * fields for the object type, branch, and project.
 */
function api_search_apachesolr_index_document_build_node(ApacheSolrDocument $document, $entity, $env_id) {
  if ($entity->type != 'api') {
    return;
  }

  // The first time this is called during an indexing run, there will be
  // PHP notices in the apachesolr.index.inc function entity_bundle_label()
  // because the API "content type" is not a real bundle. So, get around this.
  // First, trigger generating the list of labels.
  $label = entity_bundle_label('node', 'api');
  // Then, fix it up so next time we don't get more PHP notices.
  $labels = &drupal_static('entity_bundle_label', array());
  if (!empty($labels) && !isset($labels['node']['api'])) {
    $labels['node']['api'] = t('API documentation');
  }

  // Load the documentation object.
  $did = (int) $entity->nid;
  if ($did <= 0) {
    return;
  }
  $doc = api_object_load($did, NULL, 'function');
  if (!$doc || !$doc->branch_id) {
    return;
  }

  // Build the "node" title.
  $title = api_search_make_node_title($doc);
  if ($title) {
    $document->label = $title;
  }

  // Add field information (single-string dynamic fields) for Branch, Project,
  // and Object type.
  $branch = api_get_branch_by_id($doc->branch_id);
  if ($branch) {
    $document->addField('ss_apidoc_branch', $branch->title);
    $document->addField('ss_apidoc_project', $branch->project_title);
  }

  $document->addField('ss_apidoc_type', $doc->object_type);
}

/**
 * Implements hook_facetapi_facet_info().
 *
 * Tells Facet API about the Branch, Project, and Object Type fields.
 */
function api_search_facetapi_facet_info(array $searcher_info) {
  $fields = array(
    'ss_apidoc_branch' => array(t('Branch'), t('Branch the API documentation is in')),
    'ss_apidoc_project' => array(t('Project'), t('Project the API documentation is in')),
    'ss_apidoc_type' => array(t('Object type'), t('Function, class, etc.')),
  );

  $facets = array();

  foreach ($fields as $field => $info) {
    $facets[$field] = array(
      'name' => $field,
      'label' => $info[0],
      'description' => $info[1],
      'query types' => array('term'),
    );
  }

  return $facets;
}

/**
 * Makes a "node" title for an API documentation item.
 *
 * @param $doc
 *   Loaded documentation object.
 *
 * @return string
 *   A title to use, or an empty string if one could not be generated.
 */
function api_search_make_node_title($doc) {
  // Load the branch.
  $branch = api_get_branch_by_id($doc->branch_id);
  if (!$branch || !$branch->branch_id) {
    return '';
  }

  $title = array();

  $title[] = $doc->title;

  if ($doc->object_type != 'group' && $doc->object_type != 'file') {
    $title[] = trim($doc->modifiers . ' ' . $doc->object_type);
  }

  if ($doc->object_type !== 'file') {
    $title[] = basename($doc->file_name);
  }

  $title[] = $branch->title;

  return implode(' | ', $title);
}
